---
author: 
owner: 
lastupdate: 
---

# Rules creation basics

---

**NOTE**

The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability.

---

Gaia extends C++ with declarative programming functionality. These declarative extensions couple directly with Gaia’s in-memory database, where you can model your application’s state and data. When the data changes, declarative policies are immediately dispatched to trigger high-speed, responsive behavior.

The Gaia Platform fires rules in response to database events. Rules are bound to the tables and Active Fields defined in your schema. Your procedural code is where the transactions occur that trigger the rules you define, and you must commit the transaction before the rule will fire.

When writing your declarative code, keep in mind that each rule runs within a separate OS thread, and each thread can only have one outstanding transaction at a time. This provides transaction isolation. Two simultaneously running rules (each with a unique thread and transaction) will never see each other's changes. efore the rest of the system can the actions resulting from the rule can be seen, the rule must exit to commit the transaction.

To state this another way:

-   Rules run on separate threads. When data identified by an Active Field changes, your app to check the database before rules based on the field run.
-   Rules processing is atomic. A rule must complete before you can see the results of actions due to the changes.

**Important**: Be careful with the use of objects that have a shared mutable state, such as static variables. There are no protections in place to prevent all the usual race conditions, timing, and visibility issues common in other procedural programming. In short, all multithreading best practices apply when dealing with procedural code.

The true power of rules comes from the fact that they simplify the code required to realize your application.

### Active Fields

Active Fields are Database Column names that you refer to in the body of a Declarative Rule expression. When your declarative code refers to one of these Fields with a read operation, code generated by Gaia subscribes the rule to all changes to that field.

Whenever the active field is updated and committed, Gaia triggers an Event that schedules the associated Declarative Rules execute. When the Rule is executed, the row that was operated on is delivered to the rule as an automatic parameter.

You can specify which fields are active in two ways:

- By prepending an `@` symbol to the field:
    ```if (@person.location == some_location) ...```
- By specifying fields in an OnUpdate or OnChange attribute:
    ```cpp
    OnChange(person.location){
        ...
    }
    ```

**NOTE**: These two methods of specifying the active fields in a rule are mutually exclusive. If you inadvertently mix them, gaiat notifies you with the following error message: "Since a rule attribute was provided, specifying active fields inside the rule is not supported."

If your rule is simple, using the @ symbol is an easy way to visually identify which fields are active and where they are used.

If your rule is more complex, keeping track of the active fields using the @ identifier method can become confusing. In this case, identifying all of the Active Fields using an 'On' attribute keeps your rules cleaner and allows you to identify all of the active fields at a glance.
          
Active Fields specified by prepending the @ symbol create a subscription by reading the field. There are several ways to use an Active Field to read it's value create the subscription to the rule:

-   Use it in a conditional statement. For example:
```cpp
    if (@person.location == some_location) ...
```
-   Pass it as a parameter to another function.
-   Read it or write to it. For example, read the Active Field named *location* so that we can append "..." to it and then write the updated value:
```cpp
    @person.location += "..."
```                                                                                                                             

When the rules use the OnUpdate or OnChange attributes to specify the Active Fields, the subscription to changes is created whether or not you use the field in the rule. This is useful when you need to perform an action but do not need the value of changed column.

### Acting on inserts to a table

To specify that your rule fires when a new record is inserted in the table, use the OnInsert attribute.

The following rule snippet watches for an insert into the names table:

```cpp
OnInsert(names)
{
    ...
}
```

### Forward chaining of events

A compelling design concept of applications written in Gaia is the idea
of “forward chaining.” forward chaining occurs when the firing of one
rule results in a change to the state of the database that immediately
triggers the firing of a subsequent rule.

## Creating a ruleset

Rules are simple, grouped by named blocks called “rulesets”. Rulesets
are typically contained in files with extension .ruleset. They are
written using special Gaia Declarative Syntax extensions to C++ (and
other host languages in the future). This is composed of a modified
version of C++ code that includes ways to refer directly to fields in
the database in novel and powerful ways.

Note: Do not modify these files directly. If you need to update the
rules, modify the .ruleset file and run gaiat again.

The following template shows the basic format of a ruleset declaration.

```cpp
ruleset <namespace>
{
    {
        //body of rule
    }

    {    
        //body of rule
    }
…
}
```

The following ruleset declaration is from the Hello sample included with
the Gaia SDK.

```cpp
ruleset hello_ruleset
{
    // Rule 1: Whenever a name is inserted,
    // insert a new greeting into the greetings table.
    OnInsert(names)
    {
        // Form the greeting using the name.
        string new_greeting = "Hello " + string(names.name) + "!";

        // Insert the greeting.
        gaia::hello::greetings_t::insert_row(new_greeting.c_str());
    }
    // Rule 2: Whenever a greeting is inserted,
    // output it to the console.
    OnInsert(greetings)
    {
        // Output the greeting to the console.
        cout << endl << greetings.greeting << endl;
    }
}
```

In this simple example the ruleset is driven by events on two tables: names and greetings. Each table has a single field and that field has been defined as Active: names.name and greetings.greeting.

When a process inserts a name into the names table, Gaia detects that change and bundles up the changes. It then checks to see if any rules are subscribed to the changes. If there are, it inserts the changes in a queue and rules engine worker threads fire the rule, in this case rule #1.

The rule checks to see if it was an insert operation. If it was an insert operation, the rule inserts a new row into the greetings table. Gaia detects that change and bundles up the changes. It then checks to see if any rules are subscribed to the changes. If there are, it inserts the changes in a queue and rules engine worker threads fire the rule, in this case rule #2.

This is an example of forward chaining. The first rule causes a change in state to the database, a row insertion, that triggers the second rule.

When a process updates and commits name to the greetings table, the rules engine is notified by the database that a change has occurred. The rules engine receives a pointer to the exact row that changed. The pointer references an id that specifies the entities affected.

In code you can retrieve this id by calling the gaia\_id() method. The Gaia ID provides the changed row in the context for the rule's execution. Using the Gaia ID your rule can retrieve the object that triggered the rule to perform operations on it using the EDC API.

## Analyzing your rules

### Rule Statistics

The rules engine logs statistics according to settings in the
\`gaia.conf\` configuration. The following options determining logging
behavior:

| Option                       | Default if Unspecified | Description    |
|------------------------------|------------------------|----------------|
| stats\_log\_interval         | 10 seconds             | The interval in seconds for how frequently the rules engine logs statistics. All stats (counts, averages, etc) are calculated anew for each interval. |
| log\_individual\_rule\_stats | False                  | If set to true, then in addition to rollup statistics for all rules, the same statistics are calculated for each rule. |

Here is sample output when of the rule\_stats log when individual rule
statistics are not collected:

```
2020-11-30T15:15:37 30026 <rules_stats>;: 
------------------------- sched invoc pend aband retry excep avg lat max
lat avg exec max exec

2020-11-30T15:15:37 30026 <rules_stats>;: thread load:
0.49 % 21 21 0 0 0 0 15.26 ms 23.59 ms 1.46 ms 9.31 ms

2020-11-30T15:15:47 30026 <rules_stats>;: thread load:
0.65 % 30 30 0 0 0 0 13.66 ms 19.66 ms 0.28 ms 7.01 ms
```

For example, the first data row shows that 21 rules were scheduled and
21 rules were invoked.

If individual rule statistics are turned on, sample output might look
like:

```
2020-11-30T15:13:25 28975 <rules_stats>:
------------------------- sched invoc pend aband retry excep avg lat max
lat avg exec max exec

2020-11-30T15:13:25 28975 <rules_stats>: thread load:
0.73 % 28 28 0 0 0 1 15.11 ms 24.91 ms 0.74 ms 10.61 ms

2020-11-30T15:13:25 28975 <rules_stats>;:
incubator_ruleset::1_sensor 27 27 0 0 0 1 15.25 ms 24.91 ms 0.77 ms
10.61 ms

2020-11-30T15:13:25 28975 <rules_stats>;:
incubator_ruleset::3 1 1 0 0 0 0 11.30 ms 11.30 ms 0.01 ms 0.01 ms
```

Here we see that of the 28 scheduled/invocations in this time interval, the rules engine invoked **incubator_ruleset::1_sensor**  27 times and **incubator_ruleset::3** once.

### Rule Tracing

To display the rules traces to the console, edit your *gaia\_log.conf* file and add the following entry:

```
logger
name = "rules"
sinks = "console",
"file_rotating"
level = "trace"
```

Sample output from on console will appear similar to the following:

```
2020-11-30T15:35:33-08:00 trace 30862 30878 &lt;rules&gt;:
call: incubator_ruleset::1_sensor

2020-11-30T15:35:33-08:00 trace 30862 30874 &lt;rules&gt;:
call: incubator_ruleset::1_sensor

2020-11-30T15:35:33-08:00 trace 30862 30878 &lt;rules&gt;:
return: incubator_ruleset::1_sensor

2020-11-30T15:35:33-08:00 trace 30862 30874 &lt;rules&gt;:
return: incubator_ruleset::1_sensor
```

Note that the first number following "trace" is the process id. The
second number is the thread id.

If an exception occurs, the tracing displays output similar to the
following:

```
2020-11-30T15:46:34-08:00 trace 31036 31068 &lt;rules&gt;:
exception: incubator_ruleset::2, The rules engine has not been
initialized yet.
```