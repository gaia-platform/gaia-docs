---
author: 
owner: 
lastupdate: 
---

# Rules creation basics

---

**NOTE**

The information contained in this document represents information about prerelease features of the product. Features might change when the product is released for general availability.

---

Gaia extends C++ with declarative programming functionality. These declarative extensions couple directly with Gaia’s in-memory database, where you can model your application’s state and data. When the data changes, declarative policies are immediately dispatched to trigger high-speed, responsive behavior.

The Gaia Platform fires rules in response to database events. Rules are bound to the tables and Active Fields defined in your schema. Your procedural code is where the transactions occur that trigger the rules you define and you must commit the transaction before the rule will fire.

When writing your declarative code, keep in mind that each rule runs within a separate OS thread, and each thread can only have one outstanding transaction at a time. This provides transaction isolation which means, two simultaneously running rules (each with a unique thread and transaction) will never see each other's changes. Before the actions resulting from the rule can be seen by the rest of the system the rule must exit to commit it’s transaction.

To state this another way:

-   Rules run on separate threads. When data identified by an Active Field changes, it is possible for your app to check the database before   rules based on the field run.
-   Rules processing is atomic, a rule must complete before you can see the results of actions due to the changes.

**Important**: Be careful with the use of objects that have a shared mutable state, such as static variables. There are no protections in place to prevent all the usual race conditions, timing, and visibility issues common in other procedural programming. In short, all multithreading best practices apply when dealing with procedural code.

The true power of rules comes from the fact that with this syntax they simplify the code required to realize your application.

### Operations on Active Fields

Active Fields are Database Column names that you refer to in the body of a Declarative Rule expression. When your declarative code refers to one
of these Fields with a read operation, code generated by Gaia subscribes the rule to all changes to that field.

Whenever the active field is updated and committed, Gaia triggers an Event that schedules the associated Declarative Rules execute. When the Rule is executed, the row that was operated on is delivered to the rule as an automatic parameter.

To create a subscription to a rule, your rule must read an Active Field that you have defined in your DDL. There are several ways to use an Active Field to read it’s value to trigger the rule:

-   Use it in a conditional statement. For example:

if (person.location == some\_location) ...

-   Pass it as a parameter to another function.

-   Read it or write to it. For example:

person.location += "..."
>
The example statement reads the Active Field named *location* so that
we can append "..." to it and then it writes the updated value.

### Reading an active field without triggering a rule

There are times that you might need to read an Active Field but you
don’t want to trigger rules that are based on that Field. For example,
you might want to include the Field in a calculation that shouldn’t fire
associated rules.

To prevent the read operation from triggering rules, prepended the Field
with an **@** symbol.

savedLocation = @person.location;

This suppresses the Active behavior of the Field in the rule.

### Use LastOperation to watch for changes to a table

The Gaia Platform implements the LastOperation property on tables to
provide a way for your Declarative Code to react to any change to a
table. Your Declarative Rule can monitor a table for the following
events: INSERT, UPDATE, and DELETE.

For example, if you include a condition on &lt;table&gt;.LastOperation
== UPDATE then the rule fires if **any** field changes in a record in
the specified table.

The following rule snippet watches for an insert into the names table:

if (names.LastOperation == INSERT)

{

...

}

### Forward chaining of events

A compelling design concept of applications written in Gaia is the idea
of “forward chaining.” forward chaining occurs when the firing of one
rule results in a change to the state of the database that immediately
triggers the firing of a subsequent rule.

## Creating a ruleset

Rules are simple, grouped by named blocks called “rulesets”. Rulesets
are typically contained in files with extension .ruleset. They are
written using special Gaia Declarative Syntax extensions to C++ (and
other host languages in the future). This is composed of a modified
version of C++ code that includes ways to refer directly to fields in
the database in novel and powerful ways.

Note: Do not modify these files directly. If you need to update the
rules, modify the .ruleset file and run gaiat again.

The following template shows the basic format of a ruleset declaration.

ruleset &lt;namespace&gt;

{

{

//body of rule

}

{

//body of rule

}

…

}

The following ruleset declaration is from the Hello sample included with
the Gaia SDK.

ruleset hello\_ruleset

{

// Rule 1: Whenever a name is inserted,

// insert a new greeting into the greetings table.

{

// This LastOperation reference indicates to Gaia

// that this rule should be triggered

// by any insertion made into the names table.

if (names.LastOperation == INSERT)

{

// Form the greeting using the name.

string new\_greeting = "Hello " + string(names.name) + "!";

// Insert the greeting.

gaia::hello::greetings\_t::insert\_row(new\_greeting.c\_str());

}

}

// Rule 2: Whenever a greeting is inserted,

// output it to the console.

{

// This LastOperation reference indicates to Gaia

// that this rule should be triggered

// by any insertion made into the greetings table.

if (greetings.LastOperation == INSERT)

{

// Output the greeting to the console.

cout &lt;&lt; endl &lt;&lt; greetings.greeting &lt;&lt; endl;

}

}

}

In this simple example the ruleset is driven by events on two tables:
names and greetings. Each table has a single field and that field has
been defined as Active: names.name and greetings.greeting.

When a process inserts a name into the names table, Gaia detects that
change and bundles up the changes. It then checks to see if any rules
are subscribed to the changes. If there are, it inserts the changes in a
queue and rules engine worker threads fire the rule, in this case rule
\#1.

The rule checks to see if it was an insert operation. If it was an
insert operation, the rule inserts a new row into the greetings table.
Gaia detects that change and bundles up the changes. It then checks to
see if any rules are subscribed to the changes. If there are, it inserts
the changes in a queue and rules engine worker threads fire the rule, in
this case rule \# 2.

This is an example of forward chaining. The first rule causes a change
in state to the database, a row insertion, that triggers the second
rule.

When a process updates and commits name to the greetings table, the
rules engine is notified by the database that a change has occurred. The
rules engine receives a pointer to the exact row that changed. The
pointer references an id that specifies the entities affected.

In code you can retrieve this id by calling the gaia\_id() method. The
Gaia ID provides the changed row in the context for the rule’s
execution. Using the Gaia ID your rule can retrieve the object that
triggered the rule to perform operations on it using the EDC API.

## Analyzing your rules

### Rule Statistics

The rules engine logs statistics according to settings in the
\`gaia.conf\` configuration. The following options determining logging
behavior:

| Option                       | Default if Unspecified | Description                                                                                                                                           |
|------------------------------|------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| stats\_log\_interval         | 10 seconds             | The interval in seconds for how frequently the rules engine logs statistics. All stats (counts, averages, etc) are calculated anew for each interval. |
| log\_individual\_rule\_stats | False                  | If set to true, then in addition to rollup statistics for all rules, the same statistics are calculated for each rule.                                |

Here is sample output when of the rule\_stats log when individual rule
statistics are not collected:

\[2020-11-30T15:15:37\] \[30026\] &lt;rules\_stats&gt;:
------------------------- sched invoc pend aband retry excep avg lat max
lat avg exec max exec

\[2020-11-30T15:15:37\] \[30026\] &lt;rules\_stats&gt;: \[thread load:
0.49 %\] 21 21 0 0 0 0 15.26 ms 23.59 ms 1.46 ms 9.31 ms

\[2020-11-30T15:15:47\] \[30026\] &lt;rules\_stats&gt;: \[thread load:
0.65 %\] 30 30 0 0 0 0 13.66 ms 19.66 ms 0.28 ms 7.01 ms

For example, the first data row shows that 21 rules were scheduled and
21 rules were invoked.

If individual rule statistics are turned on, sample output might look
like:

\[2020-11-30T15:13:25\] \[28975\] &lt;rules\_stats&gt;:
------------------------- sched invoc pend aband retry excep avg lat max
lat avg exec max exec

\[2020-11-30T15:13:25\] \[28975\] &lt;rules\_stats&gt;: \[thread load:
0.73 %\] 28 28 0 0 0 1 15.11 ms 24.91 ms 0.74 ms 10.61 ms

\[2020-11-30T15:13:25\] \[28975\] &lt;rules\_stats&gt;:
incubator\_ruleset::1\_sensor 27 27 0 0 0 1 15.25 ms 24.91 ms 0.77 ms
10.61 ms

\[2020-11-30T15:13:25\] \[28975\] &lt;rules\_stats&gt;:
incubator\_ruleset::3 1 1 0 0 0 0 11.30 ms 11.30 ms 0.01 ms 0.01 ms

Here we see that of the 28 scheduled/invocations in this time interval,
**incubator\_ruleset::1\_sensor** was invoked 27 times and
**incubator\_ruleset::3** was invoked 1 time.

### Rule Tracing

One can also enable tracing of rules to the console by changing the
trace level of the **rules** logger to "trace". editing their
*gaia\_log.conf* file. Adding the following entry to the
*gaia\_log.conf* file will turn on rule specific tracing:

\[\[logger\]\]

name = "rules"

sinks = \[

"console",

"file\_rotating"

\]

level = "trace"

Sample output from the console looks like:

\[2020-11-30T15:35:33-08:00\] \[trace\] \[30862 30878\] &lt;rules&gt;:
call: incubator\_ruleset::1\_sensor

\[2020-11-30T15:35:33-08:00\] \[trace\] \[30862 30874\] &lt;rules&gt;:
call: incubator\_ruleset::1\_sensor

\[2020-11-30T15:35:33-08:00\] \[trace\] \[30862 30878\] &lt;rules&gt;:
return: incubator\_ruleset::1\_sensor

\[2020-11-30T15:35:33-08:00\] \[trace\] \[30862 30874\] &lt;rules&gt;:
return: incubator\_ruleset::1\_sensor

Note that the first number following "\[trace\]" is the process id. The
second number is the thread id.

If an exception occurs, the tracing displays output similar to the
following:

2020-11-30T15:46:34-08:00\] \[trace\] \[31036 31068\] &lt;rules&gt;:
exception: incubator\_ruleset::2, The rules engine has not been
initialized yet.
